import requests
from openpyxl import load_workbook
from pathlib import Path
import csv
import time
import os

BASE = 'https://cveawg.mitre.org/api'
EPSSBASE = 'https://api.first.org/data/v1/epss?cve='
cve_list = []
vendor = []
product = []
aff_version = []
url = []
epss = []
severity = []
row_count = 0
total_time = 0
base_severity = 'TBD'
base_score = 'TBD'
final_str_ver_array = []
fp = Path(__file__).parent / "CVE.xlsx"
new_csv = 'output.csv'

#to read file
def read_wb(fp):
    wb = load_workbook(filename=fp)
    sheet = wb.active
    num_rows = 0

    for row in sheet:
        if not all([cell.value == None for cell in row]):
            num_rows += 1

    for row in sheet.iter_rows(min_row=1, max_col=1, max_row=num_rows): #min_row is the row to start reading
        for cell in row:
            cve_list.append(cell.value)

def EPSS(cve_id):
    # Batch: show EPSS scores for a list of CVEs, https://api.first.org/data/v1/epss?cve=CVE-2022-27225,CVE-2022-27223,CVE-2022-27218
    epss_response = requests.get(EPSSBASE + f'{cve_id}')
    value = epss_response.json()['data'][0]['epss']
    value = float(value) * 100
    value = round(value, 2)
    return value

def main():
    script_dir = os.path.dirname(os.path.abspath(__file__))
    output_path = os.path.join(script_dir, new_csv)

    read_wb(fp)
    i=0 # this counter is for increasing number of rows in csv
    start = time.time()

    print(f'\nProgram is running...\n')

    with open(output_path, 'w+') as csvFile:
        csvwriter = csv.writer(csvFile)
        csvwriter.writerow(['CVE ID','EPSS','Severity','CVSS Score','Vendor','Product','Affected Version','References'])
        for cve_id in cve_list:
            
            response = requests.get(BASE + f'/cve/{cve_id}')
            global base_severity
            global base_score
            print(f'\nChecking {cve_id}:\n')

            if(response.status_code == 200) :
                try: # metrics
                    metrics = response.json()['containers']['cna']['metrics']

                    for i in range(len(metrics)):
                        for j in metrics[i]:
                            
                            if 'baseSeverity' in metrics[i][j]:
                                base_severity = metrics[i][j]['baseSeverity']

                            if 'baseScore' in metrics[i][j]:
                                base_score = metrics[i][j]['baseScore']
                                                    
                except KeyError:
                    print(f'    Base score and base severity not found')
            
                try: # references
                    ref = response.json()['containers']['cna']['references']
                    ref_length = len(ref)

                    if ref_length > 5:
                        url.append(f'https://www.cve.org/CVERecord?id={cve_id}')

                    else:
                        for ref_count in range(ref_length):
                            if 'url' in ref[ref_count]:
                                url.append(ref[ref_count]['url'])

                except KeyError:
                    url.append(f'TBD')
                    print(f'    References not available')

                try: # list of vendors
                    list_of_ALL_aff_vendors_info = response.json()['containers']['cna']['affected']
                    num_of_aff_vendors = len(list_of_ALL_aff_vendors_info)
                    print(f'    Number of affected vendors: {num_of_aff_vendors}')
                
                except KeyError:
                    print("    List of vendors not found")
                    vendor.append('N/A')
                    product.append('N/A')
                    aff_version.append('N/A')
                    continue 
                    
                for i in range(num_of_aff_vendors):
                    global final_str_ver

                    try: # looping through each vendor
                        general_detail = response.json()['containers']['cna']['affected'][i]
                        vendor_name = general_detail['vendor']
                    
                    except KeyError:
                        print(f'    Information on vendor {i+1} not found')
                            
                    try: # looping through each product
                        product_name = response.json()['containers']['cna']['affected'][i]['product']
                        vendor.append(vendor_name)
                        product.append(product_name)
                    except KeyError:
                        print(f'    No product found')
                        
                    try: # looping through each versions
                        versions = response.json()['containers']['cna']['affected'][i]['versions']
                        num_of_version = len(versions)
                        print(f'    Number of affected versions: {num_of_version}')

                        for ver in versions:
                            status = ver['status']
                            lower_bound = ver['version']

                            if 'lessThan' in ver:
                                upper_bound = ver['lessThan']
                                aff_version.append(f'{status} version: {lower_bound} before {upper_bound}')
                            elif 'lessThanOrEqual' in ver:
                                upper_bound = ver['lessThanOrEqual']
                                aff_version.append(f'{status} version: {lower_bound} through {upper_bound}')
                            else:
                                aff_version.append(f'{status} version: {lower_bound}')

                    except KeyError:
                        print(f'    Affected version for \"{product_name}\" not found')
                        aff_version.append(f'N/A')
                        
                    # ----------- combining versions into one cell -----------------
                    str_version =  '\n     - '.join(aff_version)
                    str_version = f'{product_name}\n     - {str_version}'
                    del aff_version[:]
                    final_str_ver_array.append(str_version)
                    # ----------- combining versions into one cell -----------------

            else: # when response status code is not 200
                print(f'Error {response.status_code}')
                print(f'Tip: Ensure that there are no trailing spaces in each cell in CVE.xslx')
                vendor.append('N/A')
                product.append('N/A')
                aff_version.append('N/A')  
                i+=1

            # ------------- combining items into one cell based on its respective items ----------------
            str_vendor = '\n'.join(vendor)
            str_vendor = ''.join(('\"', str_vendor))
            str_vendor = ''.join((str_vendor, '\"'))

            str_product = '\n'.join(product)
            str_product = ''.join(('\"', str_product))
            str_product = ''.join((str_product, '\"'))

            final_str_ver = '\n'.join(final_str_ver_array)
            final_str_ver = ''.join(('\"', final_str_ver))
            final_str_ver = ''.join((final_str_ver, '\"'))

            str_url = '\n'.join(url)
            str_url = ''.join(('\"', str_url))
            str_url = ''.join((str_url, '\"'))
            # ------------- combining items into one cell based on its respective items ----------------

            # writing elements into csv fil
            csvwriter.writerow([cve_id, EPSS(cve_id), base_severity, base_score, str_vendor, str_product, final_str_ver, str_url])
            print(f'\n{cve_id} check completed')
            print(f'----------------------------------------------------------------')
            
            #resets value
            base_severity = 'TBD'
            base_score = 'TBD'
            del vendor[:]
            str_vendor = ''
            del product[:]
            str_product = ''
            del final_str_ver_array[:]
            del url[:]
            str_url = ''
            
    end = time.time()
    total_time = (end-start)
    total_time = round(total_time, 2)

    print(f'Time of execution: {total_time} s\n')
   
main()

    


